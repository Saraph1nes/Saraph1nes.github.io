---
title: V8引擎的垃圾回收
date: 2024-03-15
tags:
  - V8引擎
  - 内存管理
  - 垃圾回收
  - 性能优化
  - JavaScript引擎
---

# V8引擎的垃圾回收

<!-- DESC SEP -->

本文深入解析V8引擎垃圾回收机制，采用分代回收策略将堆内存划分为新生代与老生代：新生代使用Scavenge算法实现快速回收，老生代采用标记-清除-整理算法保障内存效率。通过并行回收、增量标记和并发回收三重优化方案，有效解决Stop-The-World性能瓶颈问题。内存管理基于可达性算法精准识别活动对象，配合写屏障技术实现并发标记。性能优化方面通过对象晋升策略控制内存碎片，并充分利用多核优势实现并行回收。

<!-- DESC SEP -->

## 垃圾数据

从 **GC Roots** 对象出发，遍历 GC Root 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据。V8 会有专门的垃圾回收器来回收这些垃圾数据。

## 垃圾回收算法

垃圾回收大致可以分为以下几个步骤：

- 第一步，**通过 GC Root 标记空间中活动对象和非活动对象**。目前 V8 采用的**可访问性（reachability）算法**来判断堆中的对象是否是活动对象。具体地讲，这个算法是将一些 GC Root 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：
  - 通过 GC Root 遍历到的对象，我们就认为该对象是**可访问的（reachable）**，那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为**活动对象**；
  - 通过 GC Roots 没有遍历到的对象，则是**不可访问的（unreachable）**，那么这些不可访问的对象就可能被回收，我们称不可访问的对象为**非活动对象**。
  - 在**浏览器环境中，GC Root 有很多**，通常包括了以下几种 (但是不止于这几种)：
    - 全局的 window 对象（位于每个 iframe 中）；
    - 文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；
    - 存放栈上变量。
- 第二步，**回收非活动对象所占据的内存**。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
- 第三步，**做内存整理**。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。但这步其实是可选的，因为**有的垃圾回收器不会产生内存碎片(比如副垃圾回收器)**。

## 垃圾回收

V8 依据**代际假说**，将堆内存划分为**新生代和老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。代际假说有两个特点：

- 第一个是大部分对象都是“**朝生夕死**”的，也就是说**大部分对象在内存中存活的时间很短**，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；
- 第二个是**不死的对象，会活得更久**，比如全局的 window、DOM、Web API 等对象。

为了提升垃圾回收的效率，V8 设置了两个垃圾回收器，主垃圾回收器和副垃圾回收器。

- **主垃圾回收器**负责收集老生代中的垃圾数据，**副垃圾回收器**负责收集新生代中的垃圾数据。
- **副垃圾回收器采用了 Scavenge 算法**，是把新生代空间对半划分为两个区域（有些地方也称作From和To空间），一半是对象区域，一半是空闲区域。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。
  - 这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。
  - 副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般**新生区的空间会被设置得比较小**。
  - 副垃圾回收器还会采用**对象晋升策略**，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。
- 主垃圾回收器回收器主要负责**老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程**。
  - 主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。
  - 老生代中的对象有两个特点：一个是对象占用空间大；另一个是对象存活时间长。

## Stop-The-World

> 由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**。

V8 最开始的垃圾回收器有两个特点：

- 第一个是垃圾回收在主线程上执行，
- 第二个特点是一次执行一个完整的垃圾回收流程。

**由于这两个原因，很容易造成主线程卡顿，所以 V8 采用了很多优化执行效率的方案。**

- 第一个方案是**并行回收**，在执行一个完整的垃圾回收过程中，垃圾回收器会使用多个辅助线程来并行执行垃圾回收。
- 第二个方案是**增量式垃圾回收**，垃圾回收器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作。
- 第三个方案是**并发回收**，回收线程在执行 JavaScript 的过程，辅助线程能够在后台完成的执行垃圾回收的操作。

资料参考：[深入解读 V8 引擎的「并发标记」技术 - OSCHINA - 中文开源技术交流社区](https://www.oschina.net/translate/v8-javascript-engine)

